# Ch.8 Virtual Memory

앞서 우리가 배우는 내용은

- 가상 메모리의 정의
- 가상 메모리가 지원하는 하드웨어와 제어 장치에 대한 설명
- 다양한 OS 매커니즘이 가상 메모리로 어떻게 구현되어있는지
- Etc..

<br/>

## **Virtual Memory?**

 보조 기억장치에 할당되어 있는 저장 공간으로 필요시 메인 메모리로 일부 옮겨질 수 있다. 뒤에서 계속 나올 내용이니 잘 기억하자.



<br/>

## 1. Hardware and control structures

 **앞서 paging과 segmentation의 두 특성을 살펴보자.**

1. 모든 메모리는 logical address를 참고하고 실행시 동적으로 physical address로 변환된다.
2. 프로세스는 실행동안 메인 메모리에 수많은 조각으로 나눠져 있고 인접해 있을 필요가 없다.

 **이전에는 메모리 관리에서 하나의 프로그램 전체를 메인 메모리에 올렸지만 가상 메모리를 활용한다면 당장 실행에 필요한 부분만 메인 메모리에 올리면 된다!**

<br>

## 2. Real and Virtual Memory

- **Real memory** : RAM의 실체로 프로세스가 실행되는 공간이다.
- **Virtual memory** : 효율적인 멀티 프로그래밍을 지원함과 동시에 사용자에게 메인 메모리의 엄격한 제약을 풀어준다.

- Simple paging **vs** Virtual Memory paging, Simple segmantation **vs** Virtual Memory segmantation

  >  두 대립구도의 차이는 실행시 모든 페이지/ 세그멘테이션이 메인 메모리에 위치하지 않아도 된다는 점이다.

- The principle of locality
  - 프로그램이나 프로세스가 참조하는 프로세스는 군집해있는 경향이 있다.
  - 프로세스의 소수 몇 조각만이 단기간동안 필요하다.
  - 그래서 미래에 어느 조각이 필요할지 영리하게 예측할 수 있어야 한다.

<br/>

## 3. Two-level Hierarchical Page Table

 앞서 우리가 32bit 주소를 4Kbyte 크기의 페이지들로 가진다 하자. 그러면 2^32 가상 주소는 2^20 페이지가 필요함. 이 많은 페이지를 메인 메모리에 둔다면 매우 비효율적이지 않을까?

- Two level scheme

  > 기본 Page table 구조는 논리적 주소를 하나의 테이블에 담았다면, 계층적 구조는 그 논리적 주소를 다시 여러 테이블로 나눈 구조를 말한다.

- Translation Lookaside Buffer (TLB)

  > 가상 메모리 참조는 두 물리적 메모리 접근을 가짐. 하나는 PTE로 접근, 하나는 데이터에 접근.
  >
  > 이 두번의 메모리 접근시간을 효율적으로 하기 위하여 빠른 속도의 특별한 캐시를 이용하는데 이를 **TLB**라 부른다.

<br/>

## 4. Page Size

 페이지 크기를 결정하는데 세가지 요인이 고려된다.

1. 내부 단편화 최소

   > 페이지 크기가 작을 수 록, 내부 단편화가 감소한다. 그말은 즉슨 많은 페이지 테이블 수가 필요로 한다.

2. Page fault의 감소화

   > 멀티 프로그래밍 환경에서 가장 큰 문제는 활성화된 프로세스의 페이지 테이블 일부는 메인 메모리 대신에 가상 메모리로 존재해야 한다.

3. 데이터 전송을 위한 더 효율적 블록

 **페이지 크기를 키워도 성능이 좋아지지 않고 페이지 수를 늘린다고 해서 좋아지는 것도 아님. 그러면 어떻게 해야할까?**

<br>

 **LRU (Least Recently Used)**

 가장 오랜 시간동안 참조되지 않은 메인 메모리의 페이지를 교체한다. 지역성의 원리에 따르면, 이 페이지는 가까운 미래에 참조될 가능성이 가장 적을 것으로 예상됨. 실제로 이 정책은 최적 정책과 가장 유사함.

 **FIFO (First-In-First-Out)**

 프로세스에 할당된 페이지 프레임들을 순환 버퍼처럼 다루어, 라운드 로빈 스타일로 프레임 상의 페이지들을 제거한다. 이 정책은 가장 쉽게 구현 가능한 페이지 교체정책 중 하나로, 페이지들을 원형으로 연결하는 포인터가 구현에 필요한 모든 것이다. 가장 먼저 들어온 페이지를 교체시킨다.

 **Clock Policy**

 각 프레임 별 *use* 비트가 필요하다. clock 알고리즘은 순환형 리스트를 유지하고, 가장 오래된 페이지를 가리키는 hand(iterator)를 가지고 있다. 페이지 폴트가 발생했고 빈 프레임이 없다면, hand가 가리키고 있는 페이지의 참조비트를 검사한다. 만약 참조비트가 클리어 상태라면 hand가 가리키고 있는 페이지가 새로운 페이지로 사용된다. 그렇지 않으면 참조비트를 클리어시킨다. 그 다음 hand는 증가하고, 페이지가 교체될 때까지 이 과정이 반복된다.

